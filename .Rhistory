summarise(Net_Price = sum(`Net Price`, na.rm = TRUE)) %>%
ungroup()
# 绘制按销售渠道的月度时间序列图，增加Y轴的可读性
ggplot(df_channel_monthly, aes(x = YearMonth, y = Net_Price, color = `Sales Channel`)) +
geom_line() +
labs(title = "Monthly Net Price Over Time by Sales Channel",
x = "Date", y = "Net Price") +
theme_minimal() +
theme(legend.position = "bottom") +
scale_y_continuous(labels = comma) +  # 使用逗号格式化Y轴数值
scale_x_date(date_labels = "%Y-%m", date_breaks = "2 month")  # 设置X轴显示格式和间隔
library(tidyverse)
library(lubridate)
library(data.table)
library(ggplot2)
library(forecast)
library(gridExtra)
library(scales)
# 读取清洗后的数据
file_path <- "D:/cleaned_transactions.csv"  # 替换为清洗后数据的文件路径
df <- fread(file_path)
# 解析日期
df$`Document Date` <- as.Date(df$`Document Date`, format = "%Y-%m-%d")
# 按日期聚合净价
df_daily <- df %>%
group_by(`Document Date`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE))
# 确保日期序列连续
df_daily <- df_daily %>%
complete(`Document Date` = seq.Date(min(`Document Date`), max(`Document Date`), by = "day")) %>%
fill(Net_Price, .direction = "downup")
# 创建时间序列对象，指定开始和结束日期
start_date <- as.numeric(format(min(df_daily$`Document Date`), "%Y"))
start_month <- as.numeric(format(min(df_daily$`Document Date`), "%m"))
ts_net_price <- ts(df_daily$Net_Price, start = c(start_date, start_month), frequency = 365)
# 季节性分解
decomp <- decompose(ts_net_price)
# 使用 ggplot2 绘制分解结果
decomp_df <- data.frame(
date = seq.Date(from = min(df_daily$`Document Date`), by = "day", length.out = length(decomp$trend)),
observed = decomp$x,
trend = decomp$trend,
seasonal = decomp$seasonal,
random = decomp$random
)
p1 <- ggplot(decomp_df, aes(x = date, y = observed)) +
geom_line(color = "blue") +
labs(title = "Observed", x = "Date", y = "Observed") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p2 <- ggplot(decomp_df, aes(x = date, y = trend)) +
geom_line(color = "blue") +
labs(title = "Trend", x = "Date", y = "Trend") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p3 <- ggplot(decomp_df, aes(x = date, y = seasonal)) +
geom_line(color = "blue") +
labs(title = "Seasonal", x = "Date", y = "Seasonal") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p4 <- ggplot(decomp_df, aes(x = date, y = random)) +
geom_line(color = "blue") +
labs(title = "Random", x = "Date", y = "Random") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
# 使用 gridExtra 包将四个图放在一起
grid.arrange(p1, p2, p3, ncol = 1)
library(tidyverse)
library(lubridate)
library(data.table)
library(ggplot2)
# 读取数据
file_path <- "D:/transactions.csv"  # 替换为你的文件路径
df <- fread(file_path)
# 解析日期
df$`Document Date` <- as.Date(df$`Document Date`, format = "%m/%d/%Y")
# 检查并移除无效日期
df <- df %>%
filter(!is.na(`Document Date`))
# 检查日期范围
start_date <- min(df$`Document Date`, na.rm = TRUE)
end_date <- max(df$`Document Date`, na.rm = TRUE)
print(paste("Date range:", start_date, "to", end_date))
# 按日期聚合净价
df_daily <- df %>%
group_by(`Document Date`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE))
# 再次检查日期范围
start_date <- min(df_daily$`Document Date`, na.rm = TRUE)
end_date <- max(df_daily$`Document Date`, na.rm = TRUE)
print(paste("Aggregated date range:", start_date, "to", end_date))
if (is.finite(start_date) & is.finite(end_date)) {
# 填补缺失值
df_daily <- df_daily %>%
complete(`Document Date` = seq.Date(start_date, end_date, by = "day")) %>%
fill(Net_Price, .direction = "downup")
} else {
stop("Invalid date range detected. Please check your data.")
}
# 绘制基础时间序列图
ggplot(df_daily, aes(x = `Document Date`, y = Net_Price)) +
geom_line() +
labs(title = "Daily Net Price Over Time", x = "Date", y = "Net Price") +
theme_minimal()
# 计算Recency, Frequency, Monetary
df$Recency <- as.numeric(difftime(max(df$`Document Date`), df$`Document Date`, units = "days"))
df_rfm <- df %>%
group_by(Customer) %>%
summarise(
Recency = min(Recency, na.rm = TRUE),
Frequency = n_distinct(`Order No`),
Monetary = sum(`Net Price`, na.rm = TRUE)
)
print(head(df_rfm))
# 示例产品代码
article_code <- "A14Y010000"  # 替换为你的产品代码
# 筛选指定产品的数据
df_product <- df %>%
filter(`Article Code` == article_code) %>%
group_by(`Document Date`, `Item Discount`) %>%
summarise(Qty = sum(Qty, na.rm = TRUE)) %>%
ungroup()
# 绘制产品销售情况
ggplot(df_product, aes(x = `Document Date`, y = Qty)) +
geom_line() +
geom_point(data = df_product %>% filter(`Item Discount` > 0), aes(color = "red")) +
scale_color_manual(values = c("red" = "red")) +
labs(title = paste("Time Series Chart for Article Code:", article_code),
x = "Document Date", y = "Qty",
color = "Item on Discount") +
theme_minimal()
# 计算每个产品是否增加销量
results_df <- df %>%
group_by(`Article Code`, `Item Discount`) %>%
summarise(Total_Sales = sum(Qty, na.rm = TRUE)) %>%
pivot_wider(names_from = `Item Discount`, values_from = Total_Sales, values_fill = 0) %>%
mutate(Increase_in_Sales = `1` > `0`) %>%
ungroup() %>%
group_by(Increase_in_Sales) %>%
summarise(Count = n())
print(head(results_df))
# 绘制分析结果
ggplot(results_df, aes(x = Increase_in_Sales, y = Count, fill = Increase_in_Sales)) +
geom_bar(stat = "identity") +
labs(title = "Sales Increase Analysis", x = "Increase in Sales", y = "Count") +
theme_minimal()
library(tidyverse)
library(lubridate)
library(data.table)
library(ggplot2)
library(forecast)
# 读取清洗后的数据
file_path <- "D:/cleaned_transactions.csv"  # 替换为清洗后数据的文件路径
df <- fread(file_path)
# 解析日期
df$`Document Date` <- as.Date(df$`Document Date`, format = "%Y-%m-%d")
# 检查并移除无效日期
df <- df %>%
filter(!is.na(`Document Date`))
# 按日期聚合净价
df_daily <- df %>%
group_by(`Document Date`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE))
# 按日期和分类聚合净价
df_category_daily <- df %>%
group_by(`Document Date`, `Category Description`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE)) %>%
ungroup()
# 按日期和销售渠道聚合净价
df_channel_daily <- df %>%
group_by(`Document Date`, `Sales Channel`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE)) %>%
ungroup()
# 绘制整体时间序列图
ggplot(df_daily, aes(x = `Document Date`, y = Net_Price)) +
geom_line() +
labs(title = "Daily Net Price Over Time",
x = "Date", y = "Net Price") +
theme_minimal()
# 绘制按分类的时间序列图
ggplot(df_category_daily, aes(x = `Document Date`, y = Net_Price, color = `Category Description`)) +
geom_line() +
labs(title = "Daily Net Price Over Time by Category",
x = "Date", y = "Net Price") +
theme_minimal() +
theme(legend.position = "bottom")
# 绘制按销售渠道的时间序列图
ggplot(df_channel_daily, aes(x = `Document Date`, y = Net_Price, color = `Sales Channel`)) +
geom_line() +
labs(title = "Daily Net Price Over Time by Sales Channel",
x = "Date", y = "Net Price") +
theme_minimal() +
theme(legend.position = "bottom")
# 按日期聚合销售数量
df_qty_daily <- df %>%
group_by(`Document Date`) %>%
summarise(Quantity = sum(Qty, na.rm = TRUE))
# 绘制销售数量时间序列图
ggplot(df_qty_daily, aes(x = `Document Date`, y = Quantity)) +
geom_line() +
labs(title = "Daily Quantity Sold Over Time",
x = "Date", y = "Quantity Sold") +
theme_minimal()
# 按日期和折扣聚合净价
df_discount_daily <- df %>%
group_by(`Document Date`, Discount > 0) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE)) %>%
ungroup() %>%
mutate(Discount_Status = ifelse(`Discount > 0`, "With Discount", "Without Discount"))
# 绘制按折扣状态的时间序列图
ggplot(df_discount_daily, aes(x = `Document Date`, y = Net_Price, color = Discount_Status)) +
geom_line() +
labs(title = "Daily Net Price Over Time by Discount Status",
x = "Date", y = "Net Price") +
theme_minimal() +
theme(legend.position = "bottom")
# 季节性分解
ts_net_price <- ts(df_daily$Net_Price, frequency = 365)
decomp <- decompose(ts_net_price)
plot(decomp)
# 按月聚合净价
df_monthly <- df_daily %>%
mutate(Month = floor_date(`Document Date`, "month")) %>%
group_by(Month) %>%
summarise(Net_Price = sum(Net_Price, na.rm = TRUE))
# 创建时间序列对象，频率设为12（表示每年12个时间点，即按月）
ts_net_price_monthly <- ts(df_monthly$Net_Price, start = c(year(min(df_monthly$Month)), month(min(df_monthly$Month))), frequency = 12)
# ACF图
ggAcf(ts_net_price_monthly) +
labs(title = "ACF of Net Price (Monthly)",
x = "Month", y = "ACF") +
scale_x_continuous(breaks = seq(0, 24, 3), labels = function(x) format(seq.Date(from = min(df_monthly$Month), by = "month", length.out = 25)[x+1], "%Y-%m"))
# PACF图
ggPacf(ts_net_price_monthly) +
labs(title = "PACF of Net Price (Monthly)",
x = "Month", y = "PACF") +
scale_x_continuous(breaks = seq(0, 24, 3), labels = function(x) format(seq.Date(from = min(df_monthly$Month), by = "month", length.out = 25)[x+1], "%Y-%m"))
pacman::p_load(prophet,seasonal,forecast,gridExtra)
library(tidyverse)
library(lubridate)
library(data.table)
library(ggplot2)
library(forecast)
library(gridExtra)
library(scales)
# 读取清洗后的数据
file_path <- "D:/cleaned_transactions.csv"  # 替换为清洗后数据的文件路径
df <- fread(file_path)
# 解析日期
df$`Document Date` <- as.Date(df$`Document Date`, format = "%Y-%m-%d")
# 按日期聚合净价
df_daily <- df %>%
group_by(`Document Date`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE))
# 确保日期序列连续
df_daily <- df_daily %>%
complete(`Document Date` = seq.Date(min(`Document Date`), max(`Document Date`), by = "day")) %>%
fill(Net_Price, .direction = "downup")
# 创建时间序列对象，指定开始和结束日期
start_date <- as.numeric(format(min(df_daily$`Document Date`), "%Y"))
start_month <- as.numeric(format(min(df_daily$`Document Date`), "%m"))
ts_net_price <- ts(df_daily$Net_Price, start = c(start_date, start_month), frequency = 365)
# 季节性分解
decomp <- decompose(ts_net_price)
# 使用 ggplot2 绘制分解结果
decomp_df <- data.frame(
date = seq.Date(from = min(df_daily$`Document Date`), by = "day", length.out = length(decomp$trend)),
observed = decomp$x,
trend = decomp$trend,
seasonal = decomp$seasonal,
random = decomp$random
)
p1 <- ggplot(decomp_df, aes(x = date, y = observed)) +
geom_line(color = "blue") +
labs(title = "Observed", x = "Date", y = "Observed") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p2 <- ggplot(decomp_df, aes(x = date, y = trend)) +
geom_line(color = "blue") +
labs(title = "Trend", x = "Date", y = "Trend") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p3 <- ggplot(decomp_df, aes(x = date, y = seasonal)) +
geom_line(color = "blue") +
labs(title = "Seasonal", x = "Date", y = "Seasonal") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p4 <- ggplot(decomp_df, aes(x = date, y = random)) +
geom_line(color = "blue") +
labs(title = "Random", x = "Date", y = "Random") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
# 使用 gridExtra 包将四个图放在一起
grid.arrange(p1, p2, p3, ncol = 1)
library(tidyverse)
library(data.table)
# 读取数据
file_path <- "D:/transactions.csv"  # 替换为你的文件路径
df <- fread(file_path)
# 解析日期
df$`Document Date` <- as.Date(df$`Document Date`, format = "%m/%d/%Y")
# 新列：Item_Type
df <- df %>%
mutate(Item_Type = case_when(
`Net Price` == 0 & str_detect(Description, "Sample|SP|SAMP|SMP") ~ "Sample",
`Net Price` == 0 & str_detect(Description, "GWP") ~ "GWP",
TRUE ~ "Paid"
))
# 新列：Series
df <- df %>%
mutate(Series = case_when(
str_detect(Description, "Invati") ~ "Invati",
str_detect(Description, "Botanical Repair") ~ "Botanical Repair",
str_detect(Description, "Colour Control") ~ "Colour Control",
str_detect(Description, "Rosemary Mint") ~ "Rosemary Mint",
TRUE ~ "Other"
))
# 筛选 Sales_Transaction = 'S' 和 Item_Type = 'Paid' 的记录
df_filtered <- df %>%
filter(`Sales Transaction Type` == 'S' & Item_Type == 'Paid')
# 查看数据清洗后的结果
head(df_filtered)
# 按日期聚合净价
df_daily <- df_filtered %>%
group_by(`Document Date`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE))
# 绘制净价格为零的记录分布情况
zero_net_price_records <- df_filtered %>%
filter(`Net Price` == 0)
# 按销售渠道分组并计算数量
channel_summary <- zero_net_price_records %>%
group_by(`Sales Channel`) %>%
summarise(Count = n())
# 绘制条形图
ggplot(channel_summary, aes(x = `Sales Channel`, y = Count, fill = `Sales Channel`)) +
geom_bar(stat = "identity") +
labs(title = "Zero Net Price Records by Sales Channel",
x = "Sales Channel", y = "Count") +
theme_minimal()
output_file_path <- "D:/cleaned_transactions.csv"  # 替换为你希望保存文件的路径
write.csv(df_filtered, output_file_path, row.names = FALSE)
library(tidyverse)
library(lubridate)
library(data.table)
library(ggridges)
library(scales)
# 解析日期
df$`Document Date` <- as.Date(df$`Document Date`, format = "%Y-%m-%d")
# 按日期和分类聚合净价
df_category_daily <- df %>%
filter(`Sales Transaction Type` == "S", `Item_Type` == "Paid") %>%
group_by(`Document Date`, `Category Description`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE), .groups = 'drop') %>%
ungroup()
# 将 Net_Price 转换为对数尺度
df_category_daily$Log_Net_Price <- log1p(df_category_daily$Net_Price)
# 创建山脊图
ridgeline_combined <- ggplot(df_category_daily, aes(x = Log_Net_Price, y = `Category Description`, fill = `Category Description`)) +
geom_density_ridges(alpha = 0.5, scale = 1, rel_min_height = 0.01) +
scale_fill_viridis_d() +
theme_ridges() +
labs(title = "Ridgeline Plot of Net Price by Category",
x = "Net Price", y = NULL) +
scale_x_continuous(labels = NULL, breaks = NULL) +  # 移除x轴标签
theme(legend.position = "right", legend.text = element_text(size = 10))
print(ridgeline_combined)
library(tidyverse)
library(lubridate)
library(data.table)
library(ggplot2)
library(forecast)
library(scales)  # 用于逗号格式化
library(tidyverse)
library(lubridate)
library(data.table)
library(ggplot2)
library(forecast)
library(scales)  # 用于逗号格式化
# 解析日期
df$`Document Date` <- as.Date(df$`Document Date`, format = "%m/%d/%Y")
# 检查并移除无效日期
df <- df %>%
filter(!is.na(`Document Date`))
# 提取年月
df <- df %>%
mutate(YearMonth = floor_date(`Document Date`, "month"))
# 按年月和销售渠道聚合净价
df_channel_monthly <- df %>%
group_by(YearMonth, `Sales Channel`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE)) %>%
ungroup()
# 绘制按销售渠道的月度时间序列图，增加Y轴的可读性
ggplot(df_channel_monthly, aes(x = YearMonth, y = Net_Price, color = `Sales Channel`)) +
geom_line() +
labs(title = "Monthly Net Price Over Time by Sales Channel",
x = "Date", y = "Net Price") +
theme_minimal() +
theme(legend.position = "bottom") +
scale_y_continuous(labels = comma) +  # 使用逗号格式化Y轴数值
scale_x_date(date_labels = "%Y-%m", date_breaks = "2 month")  # 设置X轴显示格式和间隔
library(tidyverse)
library(lubridate)
library(data.table)
library(ggplot2)
library(forecast)
library(gridExtra)
library(scales)
# 读取清洗后的数据
file_path <- "D:/cleaned_transactions.csv"  # 替换为清洗后数据的文件路径
df <- fread(file_path)
# 解析日期
df$`Document Date` <- as.Date(df$`Document Date`, format = "%Y-%m-%d")
# 按日期聚合净价
df_daily <- df %>%
group_by(`Document Date`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE))
# 确保日期序列连续
df_daily <- df_daily %>%
complete(`Document Date` = seq.Date(min(`Document Date`), max(`Document Date`), by = "day")) %>%
fill(Net_Price, .direction = "downup")
# 创建时间序列对象，指定开始和结束日期
start_date <- as.numeric(format(min(df_daily$`Document Date`), "%Y"))
start_month <- as.numeric(format(min(df_daily$`Document Date`), "%m"))
ts_net_price <- ts(df_daily$Net_Price, start = c(start_date, start_month), frequency = 365)
# 季节性分解
decomp <- decompose(ts_net_price)
# 使用 ggplot2 绘制分解结果
decomp_df <- data.frame(
date = seq.Date(from = min(df_daily$`Document Date`), by = "day", length.out = length(decomp$trend)),
observed = decomp$x,
trend = decomp$trend,
seasonal = decomp$seasonal,
random = decomp$random
)
p1 <- ggplot(decomp_df, aes(x = date, y = observed)) +
geom_line(color = "blue") +
labs(title = "Observed", x = "Date", y = "Observed") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p2 <- ggplot(decomp_df, aes(x = date, y = trend)) +
geom_line(color = "blue") +
labs(title = "Trend", x = "Date", y = "Trend") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p3 <- ggplot(decomp_df, aes(x = date, y = seasonal)) +
geom_line(color = "blue") +
labs(title = "Seasonal", x = "Date", y = "Seasonal") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p4 <- ggplot(decomp_df, aes(x = date, y = random)) +
geom_line(color = "blue") +
labs(title = "Random", x = "Date", y = "Random") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
# 使用 gridExtra 包将四个图放在一起
grid.arrange(p1, p2, ncol = 1)
library(tidyverse)
library(lubridate)
library(data.table)
library(ggplot2)
library(forecast)
library(gridExtra)
library(scales)
# 读取清洗后的数据
file_path <- "D:/cleaned_transactions.csv"  # 替换为清洗后数据的文件路径
df <- fread(file_path)
# 解析日期
df$`Document Date` <- as.Date(df$`Document Date`, format = "%Y-%m-%d")
# 按日期聚合净价
df_daily <- df %>%
group_by(`Document Date`) %>%
summarise(Net_Price = sum(`Net Price`, na.rm = TRUE))
# 确保日期序列连续
df_daily <- df_daily %>%
complete(`Document Date` = seq.Date(min(`Document Date`), max(`Document Date`), by = "day")) %>%
fill(Net_Price, .direction = "downup")
# 创建时间序列对象，指定开始和结束日期
start_date <- as.numeric(format(min(df_daily$`Document Date`), "%Y"))
start_month <- as.numeric(format(min(df_daily$`Document Date`), "%m"))
ts_net_price <- ts(df_daily$Net_Price, start = c(start_date, start_month), frequency = 365)
# 季节性分解
decomp <- decompose(ts_net_price)
# 使用 ggplot2 绘制分解结果
decomp_df <- data.frame(
date = seq.Date(from = min(df_daily$`Document Date`), by = "day", length.out = length(decomp$trend)),
observed = decomp$x,
trend = decomp$trend,
seasonal = decomp$seasonal,
random = decomp$random
)
p1 <- ggplot(decomp_df, aes(x = date, y = observed)) +
geom_line(color = "blue") +
labs(title = "Observed", x = "Date", y = "Observed") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p2 <- ggplot(decomp_df, aes(x = date, y = trend)) +
geom_line(color = "blue") +
labs(title = "Trend", x = "Date", y = "Trend") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p3 <- ggplot(decomp_df, aes(x = date, y = seasonal)) +
geom_line(color = "blue") +
labs(title = "Seasonal", x = "Date", y = "Seasonal") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
p4 <- ggplot(decomp_df, aes(x = date, y = random)) +
geom_line(color = "blue") +
labs(title = "Random", x = "Date", y = "Random") +
scale_y_continuous(labels = scales::comma) +
theme_minimal()
# 使用 gridExtra 包将四个图放在一起
grid.arrange(p1, p2, ncol = 1)
